import {
  onMount,
  onNotify,
  onSet
} from "./chunk-ZJIDI7JD.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/.pnpm/@nanostores+logger@0.4.0_nanostores@0.10.3/node_modules/@nanostores/logger/build-creator-logger/index.js
function onBuild(creator, listener) {
  let originBuild = creator.build;
  creator.build = (...args) => {
    let store = originBuild(...args);
    listener(store);
    return store;
  };
  return () => {
    creator.build = originBuild;
  };
}
var defaultNameGetter = (creatorName, store) => {
  return `${creatorName}:${store.value.id}`;
};
function buildCreatorLogger(creator, creatorName, events, opts = {}) {
  opts = {
    nameGetter: defaultNameGetter,
    ...opts
  };
  let messages = opts.messages || {};
  let unbind = [];
  if (messages.build !== false) {
    unbind.push(
      onBuild(creator, (store) => {
        let storeName = opts.nameGetter(creatorName, store);
        events.build({ creatorName, store, storeName });
      })
    );
  }
  return () => {
    for (let i of unbind) i();
  };
}

// node_modules/.pnpm/@nanostores+logger@0.4.0_nanostores@0.10.3/node_modules/@nanostores/logger/build-logger/index.js
var isAtom = (store) => store.setKey === void 0;
var isDeepMapKey = (key) => /.+(\..+|\[\d+\.*])/.test(key);
function handleMount(store, storeName, messages, events) {
  return onMount(store, () => {
    if (messages.mount !== false) {
      events.mount({ storeName });
    }
    return () => {
      if (messages.unmount !== false) {
        events.unmount({ storeName });
      }
    };
  });
}
function handleSet(store, storeName, events) {
  return onSet(store, ({ changed }) => {
    let oldValue = isAtom(store) ? store.value : { ...store.value };
    oldValue = isDeepMapKey(changed) ? structuredClone(oldValue) : oldValue;
    let unbindNotify = onNotify(store, () => {
      let newValue = store.value;
      let valueMessage;
      if (changed && !isDeepMapKey(changed)) {
        valueMessage = `${oldValue[changed]} → ${newValue[changed]}`;
      }
      events.change({
        changed,
        newValue,
        oldValue,
        storeName,
        valueMessage
      });
      unbindNotify();
    });
  });
}
function buildLogger(store, storeName, events, opts = {}) {
  let messages = opts.messages || {};
  let unbind = [];
  if (messages.mount !== false || messages.unmount !== false) {
    unbind.push(handleMount(store, storeName, messages, events));
  }
  if (messages.change !== false) {
    unbind.push(handleSet(store, storeName, events));
  }
  return () => {
    for (let i of unbind) i();
  };
}

// node_modules/.pnpm/@nanostores+logger@0.4.0_nanostores@0.10.3/node_modules/@nanostores/logger/printer/index.js
function badge(color) {
  return `
    padding: 0 5px 2px;
    margin-right: 5px;
    font-weight: 400;
    color: white;
    background-color: ${color};
  `;
}
function borders(full) {
  return `border-radius: ${full ? "4px" : "0 4px 4px 0"};`;
}
var STYLES = {
  badges: {
    arguments: badge("#007281"),
    build: badge("#BB5100"),
    change: badge("#0E8A00"),
    error: badge("#C30000"),
    mount: badge("#0059D1"),
    new: badge("#0C7800"),
    old: badge("#943636"),
    unmount: badge("#5E5E5E"),
    value: badge("#8A6F00")
  },
  bold: "font-weight: 700;",
  logo: `
    padding: 0 5px 2px;
    color: white;
    background-color: black;
    border-radius: 4px 0 0 4px;
  `,
  regular: "font-weight: 400;"
};
function createLog({ logo, message, type, value }) {
  let template = "";
  let args = [];
  if (logo) {
    template = `%c𝖓`;
    args.push(STYLES.logo);
  }
  if (typeof type === "string") {
    template += `%c${type}`;
    args.push(STYLES.badges[type] + borders(!logo));
  } else if (typeof type === "object") {
    template += `%c${type.name.toLowerCase()}`;
    args.push(badge(type.color) + borders(!logo));
  }
  if (message) {
    if (Array.isArray(message)) {
      message.forEach(([style, text]) => {
        template += `%c ${text}`;
        args.push(STYLES[style]);
      });
    } else {
      template += `%c ${message}`;
      args.push(STYLES.text);
    }
  }
  if (value) {
    args.push(value);
  }
  args.unshift(template);
  return args;
}
var log = (args) => console.log(...createLog(args));
var group = (args) => console.groupCollapsed(...createLog(args));
var groupEnd = () => console.groupEnd();

// node_modules/.pnpm/@nanostores+logger@0.4.0_nanostores@0.10.3/node_modules/@nanostores/logger/logger/index.js
function createLogger(store, storeName, opts) {
  return buildLogger(
    store,
    storeName,
    {
      change: ({ changed, newValue, oldValue, valueMessage }) => {
        let groupLog = {
          logo: true,
          message: [
            ["bold", storeName],
            ["regular", "store was changed"]
          ],
          type: "change"
        };
        if (changed) {
          groupLog.message.push(
            ["regular", "in the"],
            ["bold", changed],
            ["regular", "key"]
          );
        }
        group(groupLog);
        if (valueMessage) {
          log({
            message: valueMessage,
            type: "value"
          });
        }
        log({
          type: "new",
          value: newValue
        });
        if (oldValue) {
          log({
            type: "old",
            value: oldValue
          });
        }
        groupEnd();
      },
      mount: () => {
        log({
          logo: true,
          message: [
            ["bold", storeName],
            ["regular", "store was mounted"]
          ],
          type: "mount"
        });
      },
      unmount: () => {
        log({
          logo: true,
          message: [
            ["bold", storeName],
            ["regular", "store was unmounted"]
          ],
          type: "unmount"
        });
      }
    },
    opts
  );
}
function logger(stores, opts = {}) {
  let unbind = Object.entries(stores).map(
    ([storeName, store]) => createLogger(store, storeName, opts)
  );
  return () => {
    for (let i of unbind) i();
  };
}

// node_modules/.pnpm/@nanostores+logger@0.4.0_nanostores@0.10.3/node_modules/@nanostores/logger/creator-logger/index.js
function createCreatorLogger(creator, creatorName, opts) {
  let unbind = [];
  unbind.push(
    buildCreatorLogger(
      creator,
      creatorName,
      {
        build: ({ store, storeName }) => {
          log({
            logo: true,
            message: [
              ["bold", storeName],
              ["regular", "store was built by"],
              ["bold", creatorName],
              ["regular", "creator"]
            ],
            type: "build"
          });
          unbind.push(logger({ [storeName]: store }, opts));
        }
      },
      opts
    )
  );
  return () => {
    for (let i of unbind) i();
  };
}
function creatorLogger(creators, opts = {}) {
  let unbind = Object.entries(creators).map(
    ([creatorName, creator]) => createCreatorLogger(creator, creatorName, opts)
  );
  return () => {
    for (let i of unbind) i();
  };
}
export {
  buildCreatorLogger,
  buildLogger,
  creatorLogger,
  group,
  groupEnd,
  log,
  logger
};
//# sourceMappingURL=@nanostores_logger.js.map
